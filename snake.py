import pygame
import random

DOWN = 1
UP = 2
LEFT = 3
RIGHT = 4
SCREEN_WIDTH = 500
SCREEN_HEIGHT = 500
TILE_WIDTH = 10
TILE_HEIGHT = 10

def opposite(x):
    if x == 1:
        return 2
    elif x == 2:
        return 1
    elif x == 3:
        return 4
    elif x == 4:
        return 3

class Event:
    """this is a superclass for any events that might be generated by an
    object and sent to the EventManager
    """
    def __init__(self):
        self.name = "Generic Event"

class TickEvent(Event):
    def __init__(self):
        self.name = "CPU Event"

class QuitEvent(Event):
    def __init__(self):
        self.name = "Quit Event"

class RestartEvent(Event):
    def __init__(self):
        self.name = "Restart Event"

class MoveRequest(Event):
    def __init__(self, direction):
        self.name = "Move request"
        self.direction = direction

class MoveEvent(Event):
    def __init__(self, snake):
        self.name = "Move event"
        self.snake = snake

class MapBuiltEvent(Event):
    def __init__(self, gameMap):
        self.name = "Map Built"
        self.map = gameMap

class GameStartedEvent(Event):
    def __init__(self, game):
        self.name = "Game Started"
        self.game = game

class ApplePlaceEvent(Event):
    def __init__(self, apple):
        self.name = "Apple placed"
        self.apple = apple

class AppleEatenEvent(Event):
    def __init__(self):
        self.name = "Apple eaten"

class ExtendEvent(Event):
    def __init__(self, snake):
        self.name = "Extend Event"
        self.snake = snake

class SnakePlaceEvent(Event):
    def __init__(self, snake):
        self.name = "Snake placed"
        self.snake = snake

class GameOverEvent(Event):
    def __init__(self):
        self.name = "Game over"

class EventManager:
    """this object is responsible for coordinating most communication
    between the Model, View, and Controller.
    """
    def __init__(self ):
        from weakref import WeakKeyDictionary
        self.listeners = WeakKeyDictionary()

    #----------------------------------------------------------------------
    def registerListener( self, listener ):
        self.listeners[ listener ] = 1

    #----------------------------------------------------------------------
    def unregisterListener( self, listener ):
        if listener in self.listeners.keys():
            del self.listeners[ listener ]
        
    #----------------------------------------------------------------------
    def post( self, event ):
        if not isinstance(event, TickEvent) and not isinstance(event, MoveEvent):
            print "Message: " + event.name
        """Post a new event.  It will be broadcast to all listeners"""
        for listener in self.listeners.keys():
            #NOTE: If the weakref has died, it will be 
            #automatically removed, so we don't have 
            #to worry about it.
            listener.notify( event )


class KeyBoardController:
    def __init__(self, evManager):
        self.evManager = evManager
        self.evManager.registerListener(self)

    def notify(self, event):
        if isinstance(event, TickEvent):
            for event in pygame.event.get():
                ev = None

                if event.type == pygame.QUIT or event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
                    self.evManager.post(QuitEvent())
                elif event.type == pygame.KEYDOWN and event.key == pygame.K_SPACE:
                    ev = RestartEvent()
                elif event.type == pygame.KEYDOWN and event.key == pygame.K_UP:
                    direction = UP
                    ev = MoveRequest(direction)
                elif event.type == pygame.KEYDOWN and event.key == pygame.K_DOWN:
                    direction = DOWN
                    ev = MoveRequest(direction)    
                elif event.type == pygame.KEYDOWN and event.key == pygame.K_RIGHT:
                    direction = RIGHT
                    ev = MoveRequest(direction)
                elif event.type == pygame.KEYDOWN and event.key == pygame.K_LEFT:
                    direction = LEFT
                    ev = MoveRequest(direction)
                if ev:
                    self.evManager.post(ev)


class CPUSpinnerController:
    def __init__(self, evManager):
        self.evManager = evManager
        self.evManager.registerListener(self)

        self.go = 1

    def run(self):
        while self.go:
            event = TickEvent()
            self.evManager.post(event)

    def notify(self, event):
        if isinstance(event, QuitEvent):
            self.go = 0


class View:
    def __init__(self, evManager):
        self.evManager = evManager
        self.evManager.registerListener(self)

        pygame.init()
        clock = pygame.time.Clock()
        clock.tick(10)

        self.window = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("snake")
        self.background = pygame.Surface(self.window.get_size())
        self.background.fill((0,0,0)) # black
        self.window.blit(self.background, (0,0))
        pygame.display.flip()

        self.snakeSprites = pygame.sprite.RenderUpdates()
        self.appleSprites = pygame.sprite.RenderUpdates()

    def showSnake(self, snake):
        for s in snake.snakeList:
            bodySprite = SnakeSprite(self.snakeSprites)
            bodySprite.rect.center = s.rect.center

    def showApple(self, apple):
        appleSprite = AppleSprite(self.appleSprites)
        appleSprite.rect.center = apple.rect.center

    def extendSnake(self, snake):
        snakeSprite = SnakeSprite(self.snakeSprites)
        snakeSprite.rect.center = snake.snakeList[-1].rect.center

    def moveSnake(self, snake):
        self.snakeSprites.empty()

        for s in snake.snakeList:
            bodySprite = SnakeSprite(self.snakeSprites)
            bodySprite.rect.center = s.rect.center

    def checkCollision(self):
        for snake in self.snakeSprites:
            if pygame.sprite.spritecollide(snake, self.appleSprites, True):
                ev = AppleEatenEvent()
                self.evManager.post(ev)
        
    def gameOver(self):
        self.snakeSprites.empty()
        self.appleSprites.empty()        

    def notify(self, event):
        if isinstance(event, TickEvent):
            self.checkCollision()

            self.snakeSprites.clear(self.window, self.background)
            self.appleSprites.clear(self.window, self.background)

            self.snakeSprites.update()
            self.appleSprites.update()

            dirtyRects1 = self.snakeSprites.draw(self.window)
            dirtyRects2 = self.appleSprites.draw(self.window)
            dirtyRects = dirtyRects1 + dirtyRects2

            pygame.display.update(dirtyRects)
        elif isinstance(event, ApplePlaceEvent):
            self.showApple(event.apple)
        elif isinstance(event, SnakePlaceEvent):
            self.showSnake(event.snake)
        elif isinstance(event, ExtendEvent):
            self.extendSnake(event.snake)
        elif isinstance(event, MoveEvent):
            self.moveSnake(event.snake)
        elif isinstance(event, GameOverEvent):
            self.gameOver()


class Game:
    STATE_PREPARING = 'preparing'
    STATE_RUNNING = 'running'

    def __init__(self, evManager):
        self.evManager = evManager
        self.evManager.registerListener(self)
        self.state = Game.STATE_PREPARING
        self.players = [Player(evManager)]
        self.apples = [Apple(evManager)]

    def Start(self):
        ev = GameStartedEvent(self)
        self.evManager.post(ev)
        self.state = Game.STATE_RUNNING

    def notify(self, event):
        if isinstance(event, TickEvent):
            if self.state == Game.STATE_PREPARING:
                self.Start()

class Player():
    def __init__(self, evManager):
        self.evManager = evManager
        self.game = None
        self.name = ""
        self.evManager.registerListener(self)

        self.snake = [Snake(evManager)]

    def notify(self, event):
        pass

class SnakeSprite(pygame.sprite.Sprite):
    def __init__(self, group=None):
        pygame.sprite.Sprite.__init__(self, group)

        snakeSurface = pygame.Surface((TILE_WIDTH,TILE_HEIGHT))
        snakeSurface = snakeSurface.convert_alpha()
        snakeSurface.fill((255,255,255))
        pygame.draw.rect(snakeSurface, (0,0,0), snakeSurface.get_rect(), 1)

        self.image = snakeSurface
        self.rect = snakeSurface.get_rect()

class Snake:
    STATE_ACTIVE = 1
    STATE_INACTIVE = 0

    def __init__(self, evManager):
        self.evManager = evManager
        self.evManager.registerListener(self)

        self.state = Snake.STATE_INACTIVE
        self.snakeList = []
        self.speed = 25
        self.counter = 0

        #to prevent multiple keypresses at once
        self.moved = True

    def changeBodyDirection(self, direction):
        if self.state == Snake.STATE_INACTIVE:
            return
        elif direction == opposite(self.snakeList[0].direction):
            return

        self.snakeList[0].prevDirection = self.snakeList[0].direction
        self.snakeList[0].direction = direction
        for i in range(1, len(self.snakeList)):
            self.snakeList[i].prevDirection = self.snakeList[i].direction
            self.snakeList[i].direction = self.snakeList[i - 1].prevDirection

    def changeHeadDirection(self, direction):
        if self.state == Snake.STATE_INACTIVE:
            return
        elif direction == opposite(self.snakeList[0].direction):
            return
        elif self.moved == False:
            return

        self.snakeList[0].prevDirection = self.snakeList[0].direction
        self.snakeList[0].direction = direction
        self.moved = False

    def move(self):
        if self.state == Snake.STATE_ACTIVE:
            for snake in self.snakeList:
                snake.move()
            self.counter += self.speed
            if self.counter >= 100:
                self.counter = 0
                self.moved = True
                ev = MoveEvent(self)
                self.evManager.post(ev)
                self.changeBodyDirection(self.snakeList[0].direction)

            #collision check
            headrect = self.snakeList[0].rect
            if headrect.x < 0 or headrect.y < 0 or headrect.x > SCREEN_WIDTH - TILE_WIDTH or headrect.y > SCREEN_HEIGHT - TILE_HEIGHT:
                ev = GameOverEvent()
                self.evManager.post(ev)

            for i in range(1, len(self.snakeList)):
                if headrect.colliderect(self.snakeList[i].rect):
                    ev = GameOverEvent()
                    self.evManager.post(ev)
                    return


    def place(self, x, y, length):
        if self.state == Snake.STATE_INACTIVE:
            for i in range(length):
                self.snakeList.append(SnakePiece(x, y + TILE_HEIGHT * i, UP, self.speed, self.counter))
            self.state = Snake.STATE_ACTIVE
            ev = SnakePlaceEvent(self)
            self.evManager.post(ev)

    def extend(self):
        def calculateExtend(x, y, direction):
            if direction == UP:
                return (x, y + TILE_HEIGHT)
            elif direction == DOWN:
                return (x, y - TILE_HEIGHT)
            elif direction == LEFT:
                return (x + TILE_WIDTH, y)
            elif direction == RIGHT:
                return (x - TILE_WIDTH, y)
        
        lastSnake = self.snakeList[-1]
        coords = calculateExtend(lastSnake.rect.x, lastSnake.rect.y, lastSnake.direction)
        snakePiece = SnakePiece(coords[0], coords[1], lastSnake.direction, self.speed, self.counter)
        self.snakeList.append(snakePiece)

        ev = ExtendEvent(self)
        self.evManager.post(ev)

    def gameOver(self):
        del self.snakeList[:]
        self.counter = 0
        self.state = Snake.STATE_INACTIVE

    def notify(self,event):
        if isinstance(event, TickEvent):
            self.move()
        elif isinstance(event, GameStartedEvent) or isinstance(event, RestartEvent):
            x = random.randint(0, SCREEN_WIDTH - TILE_WIDTH)
            y = random.randint(0, SCREEN_HEIGHT - TILE_HEIGHT)
            self.place(x - x % TILE_WIDTH, y - y % TILE_HEIGHT, 3)
        elif isinstance(event, MoveRequest):
            self.changeHeadDirection(event.direction)
        elif isinstance(event, AppleEatenEvent):
            self.extend()
        elif isinstance(event, GameOverEvent):
            self.gameOver()


class SnakePiece:
    def __init__(self, x, y, direction, speed, counter):
        self.rect = pygame.Rect(x, y, TILE_WIDTH, TILE_HEIGHT)
        self.direction = direction
        self.prevDirection = None
        self.speed = speed
        self.counter = counter

    def move(self):
        self.counter += self.speed

        if self.counter >= 100:
            if self.direction == DOWN:
                self.rect.y += TILE_HEIGHT
            elif self.direction == UP:
                self.rect.y -= TILE_HEIGHT
            elif self.direction == LEFT:
                self.rect.x -= TILE_WIDTH
            elif self.direction == RIGHT:
                self.rect.x += TILE_WIDTH
            self.counter = 0


class AppleSprite(pygame.sprite.Sprite):
    def __init__(self, group = None):
        pygame.sprite.Sprite.__init__(self,group)

        appleSurface = pygame.Surface((TILE_WIDTH,TILE_HEIGHT))
        appleSurface = appleSurface.convert_alpha()
        appleSurface.fill((0,0,0))
        pygame.draw.circle(appleSurface, (255,0,0), (TILE_WIDTH/2, TILE_HEIGHT/2), TILE_WIDTH/2)

        self.image = appleSurface
        self.rect = appleSurface.get_rect()


class Apple:
    STATE_ACTIVE = 1
    STATE_INACTIVE = 0

    def __init__(self, evManager):
        self.evManager = evManager
        self.evManager.registerListener(self)
        self.state = self.STATE_INACTIVE

    def placeRandom(self):
        x = random.randint(0, SCREEN_WIDTH - TILE_WIDTH)
        y = random.randint(0, SCREEN_HEIGHT - TILE_HEIGHT)
        x = x - x%TILE_WIDTH
        y = y - y%TILE_HEIGHT
        self.rect = pygame.Rect(x, y, TILE_WIDTH, TILE_HEIGHT)
        self.state = Snake.STATE_ACTIVE
        ev = ApplePlaceEvent(self)
        self.evManager.post(ev)

    def notify(self, event):
        if isinstance(event, GameStartedEvent) or isinstance(event, AppleEatenEvent):
            self.placeRandom()
        if isinstance(event, GameOverEvent):
            self.state = self.STATE_INACTIVE
        elif isinstance(event, RestartEvent) and self.state == self.STATE_INACTIVE:
            self.placeRandom()


def main():
    evManager = EventManager()

    keybd = KeyBoardController(evManager)
    spinner = CPUSpinnerController(evManager)
    view = View(evManager)
    game = Game(evManager)

    spinner.run()


if __name__ == "__main__":
    main()